import logging
import os
import boto3
import json
from botocore.exceptions import ClientError

import datetime
from dateutil.relativedelta import relativedelta

# Set log level
log_level = os.environ.get("LOG_LEVEL", "INFO")
logging.root.setLevel(logging.getLevelName(log_level))  # type: ignore
logger = logging.getLogger(__name__)


def send_notification(subject_phrase, topic_arn, presigned_url, expiration):
    """Send the resigned_url as a notification to a SNS topic.

    Args:
        subject_phrase: Email subject
        topic_arn: The SNS topic ARN
        presigned_url: The presigend URl
        expiration: The time until expiration of presigned url

    Returns:
        No returns.
    """
    sns_client = boto3.client("sns")
    try:
        sns_client.publish(
            Subject=subject_phrase,
            TargetArn=topic_arn,
            Message="""
            This is a notification about your daily AWS spending.
            You can download them within the next {} hours from here: {}
            """.format(
                expiration / 3600, presigned_url
            ),
        )
    except Exception as e:
        raise e


def create_presigned_url(bucket, object_key, expiration_time):
    """Generate a presigned URL to share a S3 object.

    Args:
        bucket: The destination S3 bucket.
        object_key: The object key within S3.
        expiration_time: The expiration time for the URL in seconds.

    Returns:
        presigned_url: The presigned URL.
    """
    s3_client = boto3.client("s3")
    try:
        presigned_url = s3_client.generate_presigned_url(
            "get_object",
            Params={"Bucket": bucket, "Key": object_key},
            ExpiresIn=expiration_time,
        )
    except Exception as e:
        raise e
    return presigned_url


def upload_file(file_name, bucket, object_key):
    """Upload the excel file to s3.

    Args:
        file_name: The name of file to be uploaded
        bucket: The S3 Bucket to save file
        object_key: The S3 object key

    Returns:
        No return.
    """
    s3_client = boto3.client("s3")
    try:
        s3_client.upload_file(Filename=file_name, Bucket=bucket, Key=object_key)
    except Exception as e:
        raise e


def generate_excel():
    """Generate an Excel file from Cost Explorer response."""
    ce_client = boto3.client("ce")
    today = datetime.date.today()
    yesterday = today + relativedelta(days=-1)
    day_before_yesterday = yesterday + relativedelta(days=-1)
    yesterday = yesterday.strftime("%Y-%m-%d")
    day_before_yesterday = day_before_yesterday.strftime("%Y-%m-%d")
    logger.info("Start: {} | End: {}".format(yesterday, day_before_yesterday))
    try:
        response = ce_client.get_cost_and_usage(
            TimePeriod={"Start": day_before_yesterday, "End": yesterday},
            Granularity="DAILY",
            Metrics=["BlendedCost"],
            GroupBy=[{"Type": "DIMENSION", "Key": "SERVICE"}],
        )
        file_name = "/tmp/{}-costreport.xlsx".format(yesterday)
        services = []
        costs = []
        results = response["ResultsByTime"][0]["Groups"]
        for i in results:
            services.append(i["Keys"][0])
            costs.append(i["Metrics"]["BlendedCost"]["Amount"])
        data_tuples = list(zip(services, costs))
        df = pd.DataFrame(data_tuples, columns=["Service_AWS", "Amount_$"])
        df.to_excel("{}".format(file_name), index=False)
    except Exception as e:
        raise e
    return file_name


def put_job_success(codepipeline_client, job: str, message: str, output_variables):
    """Notify CodePipeline of a successful job.

    Args:
        codepipeline_client: A boto3 client object for CodePipeline
        job: The CodePipeline job ID
        output_variables: A dictonary for CodePiepline enviroment variables
        message: A string for logging purposes
    Returns:
        No return.
    """
    try:
        codepipeline_client.put_job_success_result(
            jobId=job, outputVariables=output_variables
        )
        logger.info("Putting job success: {}".format(message))
    except Exception as e:
        logger.error("Error:returning success signal to CodePipeline ... {}".format(e))
        raise e


def put_job_failure(codepipeline_client, job: str, message: str):
    """Notify CodePipeline of a failed job.

    Args:
        codepipeline_client: A boto3 client object for CodePipeline
        job: The CodePipeline job ID
        message: A message to be logged relating to the job status

    Returns:
        No return.
    """
    try:
        codepipeline_client.put_job_failure_result(
            jobId=job, failureDetails={"message": message, "type": "JobFailed"}
        )
        logger.info("Putting job failure: {}".format(message))
    except Exception as e:
        logger.error("Error: returning failure signal to CodePipeline ... {}".format(e))
        raise e


def sts_assume_role(role: str, session_name: str, account: str):
    """Assume a IAM role in this or a foreign account.

    Args:
        role: The name of the IAM role
        session_name: An arbitrary session name
        account: The account name or id. Just for logging purposes

    Returns:
        access_key: A temporary access key provided by Security Token Service (STS)
        secret_key: A temporary secret key key provided by Security Token Service (STS)
        session_token: A temporary session token provided by Security Token Service (STS)
    """
    try:
        sts_connection = boto3.client("sts")
        sts_response = sts_connection.assume_role(
            RoleArn=role, RoleSessionName=session_name,
        )
        access_key = sts_response["Credentials"]["AccessKeyId"]
        secret_key = sts_response["Credentials"]["SecretAccessKey"]
        session_token = sts_response["Credentials"]["SessionToken"]
    except Exception as e:
        logger.error(
            "Error while assuming role in other account {} ... {}".format(account, e)
        )
        raise e
    return access_key, secret_key, session_token


def delete_external_roles(
    assume_roles: list,
    accounts: list,
    commit_id: str,
    policy_name: str,
    role_name: str,
    role_session_name: str,
):
    """Delete IAM roles with role policy within foreign accounts.

    Args:
        policy_name: Name of the policy
        role_name: Name of the role
        role_session_name: Name of the STS session
        assume_roles: list of roles in foreign accounts to be assumed,
        accounts: list of foreign account ids,
        commit_id: id of the current commit from CodeCommit,
    """
    for role, account in zip(assume_roles, accounts):
        acc_key, sec_key, sess_token = sts_assume_role(
            role=role, session_name=role_session_name, account=account
        )
        client = boto3.client(
            "iam",
            aws_access_key_id=acc_key,
            aws_secret_access_key=sec_key,
            aws_session_token=sess_token,
        )
        logging.info("Deleting IAM Role ...")
        try:
            client.delete_role_policy(
                RoleName=role_name + commit_id, PolicyName=policy_name,
            )
        except ClientError as e:
            if e.response["Error"]["Code"] == "NoSuchEntity":
                try:
                    client.delete_role(RoleName=role_name + commit_id,)
                except Exception as e:
                    logger.info(
                        "Error deleting IAM role {} ... {}".format(role_name, e)
                    )
                    raise e
        try:
            client.delete_role(RoleName=role_name + commit_id,)
        except Exception as e:
            logger.info("Error deleting IAM role {} ... {}".format(role_name, e))
            raise e
        logging.info("IAM Role {} successfully deleted.".format(role_name + commit_id))


def delete_principals_management_lambdas(
    assign_lambda_name: str,
    unassign_lambda_name: str,
    assume_role: list,
    accounts: list,
):
    """Delete principal assign and unassign lambdas in foreign account.

    Args:
        assign_lambda_name: The name of Lambda for principal management
        unassign_lambda_name: The name of Lambda for principal management
        assume_role: list with roles to assume in foreign accounts
        accounts: list with ids of foreign accounts

    Returns:
        No returns
    """
    lambda_list = [assign_lambda_name, unassign_lambda_name]

    for role, account in zip(assume_role, accounts):
        acc_key, sec_key, sess_token = sts_assume_role(
            role=role, session_name="DeletePrincipalManagement", account=account
        )
        client = boto3.client(
            "lambda",
            aws_access_key_id=acc_key,
            aws_secret_access_key=sec_key,
            aws_session_token=sess_token,
        )
        for _lambda in lambda_list:
            try:
                list_response = client.get_function(
                    FunctionName=_lambda + "-" + account
                )
            except Exception as e:
                logger.error(
                    "Error Lambda function PrincipalManagement-{} not found ... {}".format(
                        account, e
                    )
                )
                raise e
            try:
                logging.info(
                    "Deleting Lambda function {} ... ".format(
                        list_response["Configuration"]["FunctionName"]
                    )
                )
                client.delete_function(
                    FunctionName=list_response["Configuration"]["FunctionName"]
                )
            except Exception as e:
                logger.error(
                    "Error deleting Lambda function PrincipalManagement-{} ... {}".format(
                        account, e
                    )
                )
                raise e


def get_user_params(job_data):
    """Decode the JSON user parameters and validates the required properties.

    Args:
        job_data: The job data structure containing the UserParameters string which should be a valid JSON structure

    Returns:
        The JSON parameters decoded as a dictionary.
    """
    try:
        # Get the user parameters which contain the stack, artifact and file settings
        user_parameters = job_data["actionConfiguration"]["configuration"][
            "UserParameters"
        ]
        decoded_parameters = json.loads(user_parameters)
        return decoded_parameters
    except Exception as e:
        logger.error("UserParameters could not be decoded as JSON ... {}".format(e))
        raise e


def delete_deployment(
    commit_id: str,
    local_role_name: str,
    local_policy_name: str,
    assign_lambda: str,
    assume_role_list: list,
    account_list: list,
    unassign_lambda: str,
):
    """Suborder handler, orchestrating all other functions.

    Args:
        assign_lambda: Name of the assign Lambda
        unassign_lambda: Name of the unassign Lambda
        account_list: List with relevant account Ids
        assume_role_list: List with IAM roles to be assumed
        local_policy_name: Name of the local policy
        local_role_name: Name of the local IAM Role
        commit_id: the current CodeCommit commit ID

    Returns:
        No returns
    """
    logger.info("Destroying Deployment Environment ...")
    try:
        logger.info("Deleting externally Lambdas foreign accounts ...")
        delete_principals_management_lambdas(
            assign_lambda_name=assign_lambda,
            unassign_lambda_name=unassign_lambda,
            accounts=account_list,
            assume_role=assume_role_list,
        )
    except ClientError as e:
        if e.response["Error"]["Code"] == "ResourceNotFoundException":
            logger.error(
                "Error while deleting Lambdas in foreign accounts ... {}".format(e)
            )
        try:
            logger.info("Deleting IAM Roles in foreign accounts")
            delete_external_roles(
                assume_roles=assume_role_list,
                accounts=account_list,
                commit_id=commit_id,
                policy_name=local_policy_name,
                role_name=local_role_name,
                role_session_name="deletePrincipalManagement",
            )
        except Exception as e:
            logger.error(
                "Error while deleting IAM Roles in foreign accounts ... {}".format(e)
            )
            raise e
        logger.info("Finished Destroying Deployment Environment ...")
    try:
        logger.info("Deleting IAM Roles in foreign accounts")
        delete_external_roles(
            assume_roles=assume_role_list,
            accounts=account_list,
            commit_id=commit_id,
            policy_name=local_policy_name,
            role_name=local_role_name,
            role_session_name="deletePrincipalManagement",
        )
    except Exception as e:
        logger.error(
            "Error while deleting IAM Roles in foreign accounts ... {}".format(e)
        )
        raise e
    logger.info("Finished Destroying Deployment Environment ...")
